<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Alieniloquent: Exposing .NET code in a DLL via C++</title>
  <link rel="stylesheet" type="text/css" href="/stylesheets/yui-reset.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/yui-fonts.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/yui-grids.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/simple-style.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/blog.css"/>
  <link href="http://blog.alieniloquent.com/feed" rel="alternate" title="main feed" type="application/rss+xml"/>
</head>
<body>
 <div id="doc" class="yui-t4">
   <div id="hd" class="content">
     <h1 id="title"><a href="http://www.alieniloquent.com/">Alieniloquent</a></h1>
     <ul id="navigation">
       <li class="first"><a href="http://blog.alieniloquent.com">blog</a></li>
       <li><a href="http://github.com/stesla">code</a></li>
       <li><a href="http://www.alieniloquent.com/resume.pdf">resum&eacute;</a></li>
     </ul>
     <br/>
   </div>
   <div id="bd">
     <div id="yui-main">
       <div class="yui-b">
         <div class="post">
  <h3><a href="/2006/12/31/exposing-net-code-in-a-dll-via-c.html" title="Permalink for this post">Exposing .NET code in a DLL via C++</a></h3>
  <p class="date">December 31st, 2006</p>
  <div class="entry"><p>At my work, we do both Delphi for Win32 and .NET. Most of our .NET coding is in C#, though, so we can&#8217;t just cross-compile. We have a number of .NET components that would be nice to use on the Win32 side (such as zip libraries), and we know its supposed to be possible, but none of us have ever gotten into the nitty gritty of actually doing it. Now, programming for Windows isn&#8217;t my favorite thing in the world. But, I do love a good technical challenge. Especially one that requires me to dust off a language I haven&#8217;t used in a while. This will be the first of a few articles documenting the things I&#8217;m learning from doing this.</p>

<p>The strategy that I&#8217;ll be using is to write a DLL in C++ that will allow the Delphi code to call into the .NET code. Microsoft&#8217;s C++ allows you to mix unmanaged and managed code fairly easily, so it makes for a very good glue layer in situations like this.</p>

<p>So, to start off, let&#8217;s make the Visual Studio project for the DLL. I&#8217;m using Visual Studio 2005 for this, and I&#8217;ll use the C++ CLR template entitled &#8220;Class Library.&#8221; I&#8217;ll give it a name &#8220;Example&#8221; and hit go. This makes most of the files that you need. Delete the class that it creates (&#8220;Class1&#8221;) and make a new one like this:</p>
<div class='highlight'><pre><code class='c'><span class='cp'>// Example.h</span>
<span class='cp'>#include &lt;vcclr.h&gt;</span>

<span class='cp'>#pragma once</span>

<span class='n'>using</span> <span class='n'>namespace</span> <span class='n'>System</span><span class='p'>;</span>

<span class='n'>namespace</span> <span class='n'>Example</span> <span class='p'>{</span>
  <span class='n'>public</span> <span class='n'>class</span> <span class='n'>Example1</span>
  <span class='p'>{</span>
  <span class='nl'>public:</span>

    <span class='n'>Example1</span><span class='p'>(</span><span class='k'>const</span> <span class='kt'>char</span> <span class='o'>*</span> <span class='n'>name</span><span class='p'>)</span>
      <span class='p'>{</span>
        <span class='n'>_name</span> <span class='o'>=</span> <span class='n'>gcnew</span> <span class='n'>String</span><span class='p'>(</span><span class='n'>name</span><span class='p'>);</span>
      <span class='p'>}</span>

    <span class='o'>~</span><span class='n'>Example1</span><span class='p'>()</span>
      <span class='p'>{</span>
      <span class='p'>}</span>

    <span class='kt'>void</span> <span class='n'>ShowName</span><span class='p'>();</span>

  <span class='nl'>private:</span>

    <span class='n'>gcroot</span><span class='o'>&lt;</span><span class='n'>String</span> <span class='o'>^&gt;</span> <span class='n'>_name</span><span class='p'>;</span>
  <span class='p'>};</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>A couple things to note about the above code. The <code>Example1</code> class is an <em>unmanaged</em> class, but the <code>_name</code> field is a managed object. The <code>gcroot</code> class takes care of telling the garbage collector about the managed string object.</p>

<p>Next, we need to export some DLL functions so that we can call them from Delphi:</p>
<div class='highlight'><pre><code class='c'><span class='cp'>// Exports.h</span>
<span class='cp'>#define DLLAPI extern &quot;C&quot; __declspec(dllexport)</span>
<span class='n'>DLLAPI</span> <span class='kt'>void</span> <span class='o'>*</span> <span class='n'>Example1Create</span><span class='p'>(</span><span class='k'>const</span> <span class='kt'>char</span> <span class='o'>*</span> <span class='n'>name</span><span class='p'>);</span>
<span class='n'>DLLAPI</span> <span class='kt'>void</span> <span class='n'>Example1Delete</span><span class='p'>(</span><span class='kt'>void</span> <span class='o'>*</span> <span class='n'>example</span><span class='p'>);</span>
<span class='n'>DLLAPI</span> <span class='kt'>void</span> <span class='n'>Example1ShowName</span><span class='p'>(</span><span class='kt'>void</span> <span class='o'>*</span> <span class='n'>example</span><span class='p'>);</span>
</code></pre>
</div>
<p>The important thing to notice here is the <code>DLLAPI</code> define. You need to put it before each function you want to export. We have to extern the functions as C-style functions so that their names don&#8217;t get mangled in the symbol table.</p>
<div class='highlight'><pre><code class='c'><span class='cp'>// Exports.cpp</span>
<span class='cp'>#include &quot;stdafx.h&quot;</span>
<span class='cp'>#include &quot;Example.h&quot;</span>
<span class='cp'>#include &quot;Exports.h&quot;</span>

<span class='n'>using</span> <span class='n'>namespace</span> <span class='n'>Example</span><span class='p'>;</span>

<span class='cp'>#define E1(p) ((Example1 *) p)</span>

<span class='n'>DLLAPI</span> <span class='kt'>void</span> <span class='o'>*</span> <span class='nf'>Example1Create</span><span class='p'>(</span><span class='k'>const</span> <span class='kt'>char</span> <span class='o'>*</span> <span class='n'>name</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='k'>return</span> <span class='n'>new</span> <span class='n'>Example1</span><span class='p'>(</span><span class='n'>name</span><span class='p'>);</span>
<span class='p'>}</span>

<span class='n'>DLLAPI</span> <span class='kt'>void</span> <span class='nf'>Example1Delete</span><span class='p'>(</span><span class='kt'>void</span> <span class='o'>*</span> <span class='n'>example</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='n'>delete</span> <span class='n'>example</span><span class='p'>;</span>
<span class='p'>}</span>

<span class='n'>DLLAPI</span> <span class='kt'>void</span> <span class='nf'>Example1ShowName</span><span class='p'>(</span><span class='kt'>void</span> <span class='o'>*</span> <span class='n'>example</span><span class='p'>)</span>
<span class='p'>{</span>
  <span class='n'>E1</span><span class='p'>(</span><span class='n'>example</span><span class='p'>)</span><span class='o'>-&gt;</span><span class='n'>ShowName</span><span class='p'>();</span>
<span class='p'>}</span>
</code></pre>
</div>
<p>Note the macro defined to do the cast. We only have to do the cast in one place right now, but as you expose more methods on the object, you&#8217;ll have to cast for every one. The macro makes it easier.</p>

<p>So to summarize what we have so far. In the DLL we have an unmanaged class which can access the managed classes in .NET. Then we expose functions which can create instances, destroy them, and call methods on them. These return pointers which the caller must manage. The pointers are passed into all of the functions which invoke methods, and those functions cast and then call.</p>

<p>In my next post I&#8217;ll show how to consume this DLL from Delphi.</p></div>
  <p class="metadata alt">You may notice that I do not provide a space
    for comments. If you want to start a conversation, you can
    <a href="mailto:blog@alieniloquent.com">email me</a>, 
    <a href="http://twitter.com/stesla">tweet at me</a>, or post
    something on your own blog.</p>
</div>

       </div>
     </div>
     <div class="yui-b">
       <div class="yui-u sidebar">
         <h2 class="sectionheader first">Archives</h2>
         <ul>
           
           <li><a href="/2011/">2011</a></li>
           
           <li><a href="/2010/">2010</a></li>
           
           <li><a href="/2009/">2009</a></li>
           
           <li><a href="/2008/">2008</a></li>
           
           <li><a href="/2007/">2007</a></li>
           
           <li><a href="/2006/">2006</a></li>
           
           <li><a href="/2005/">2005</a></li>
           
         </ul>
       </div>
     </div>
   </div>
   <div id="ft">
     <p>Layout, design, graphics, photography and text all &copy; 2005-2010 Samuel Tesla unless otherwise noted.</p>
     <p>Portions of the site layout use Yahoo! YUI Reset, Fonts &amp; Grids.</p>
   </div>
 </div>

<!-- BEGIN GOOGLE ANALYTICS -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-12538528-2");
pageTracker._setDomainName(".alieniloquent.com");
pageTracker._trackPageview();
} catch(err) {}</script>
<!-- END GOOGLE ANALYTICS -->

</body>
</html>
