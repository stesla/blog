<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Alieniloquent: <code>you.would? like(:fries).with(that)</code></title>
  <link rel="stylesheet" type="text/css" href="/stylesheets/yui-reset.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/yui-fonts.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/yui-grids.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/simple-style.css"/>
  <link rel="stylesheet" type="text/css" href="/stylesheets/blog.css" />
</head>
<body>
 <div id="doc" class="yui-t4">
   <div id="hd" class="content">
     <h1 id="title"><a href="http://www.alieniloquent.com/">Alieniloquent</a></h1>
     <ul id="navigation">
       <li class="first"><a href="http://blog.alieniloquent.com">blog</a></li>
       <li><a href="http://github.com/stesla">code</a></li>
       <li><a href="http://www.alieniloquent.com/resume.pdf">resum&eacute;</a></li>
     </ul>
     <br/>
   </div>
   <div id="bd">
     <div id="yui-main">
       <div class="yui-b">
         <div class="post">
  <h3><a href="/2010/01/27/you-would-like-fries-with-that.html" title="Permalink for this post"><code>you.would? like(:fries).with(that)</code></a></h3>
  <p class="date">January 27th, 2010</p>
  <div class="entry"><p>I was recently linked to an insightful article about how <a href='http://www.gamearchitect.net/Articles/SoftwareIsHard.html'>software is hard</a>. He makes several good points, but the one that sticks out most in my mind is the following:</p>

<blockquote>
<p>Every software engineer has a low opinion of the way we develop software. Even the term &#8220;software engineering,&#8221; Rosenberg writes, is a statement of hope, not fact. He quotes the 1968 NATO <a href='http://homepages.cs.ncl.ac.uk/brian.randell/NATO/NATOReports/index.html'>Software Engineering Conference</a> that coined the term: &#8220;We undoubtedly produce software by backward techniques.&#8221; &#8220;We build systems like the Wright brothers built airplanes&#8211;build the whole thing, push it off the cliff, let it crash, and start over again.&#8221; Certainly statements that could still be made forty years later.</p>
</blockquote>

<p>That is so true, especially when it comes to the programming languages we use. Most of the languages with widespread use in industry today are essentially thirty years old, and even those are just the latest in a long <a href='http://www.levenez.com/lang/'>lineage</a> that leads back to FORTRAN and Lisp in the late sixties. Languages in today&#8217;s generation don&#8217;t do anything for you that their ancestors didn&#8217;t do forty years ago.</p>

<p>What&#8217;s worse is that more modern languages exist&#8211;they have existed for decades&#8211;yet they don&#8217;t find mainstream adoption. For the last twenty years the main thrust of innovation in the software industry has been focused on people and process rather than languages and tools. Modern languages are dismissed as academic, and industry experts are struggling to find new and better ways to build useful systems with ancient technology.</p>

<p>We are rapidly approaching a singularity after which the descendants of FORTRAN and Lisp will be grossly inadequate for writing programs. The current rise of concurrent programming is just the beginning. As time plods on and concurrency and distributed programming become more commonplace, we are going to have to develop new ways of writing software.</p>

<p>This really isn&#8217;t news. Software is hard. Concurrent software is harder. We know that. The solutions offered today are primitive, and not much different from the thinking over thirty years ago. Whether you use some shared-memory model or some message-passing model, writing concurrent programs is a mentally exhausting process with a lot of work centered around getting the parallelism right.</p>

<p>Another problem we face is the increasing ubiquity of software. In the modern, Western world it is nearly impossible to take ten steps without walking past at least a hundred semiconductors. Many of those little bits of manufactured silicon are running some sort of program (whether it is firm or software). We passed the point in time where our lives are computerized a long time ago, and many people didn&#8217;t even notice. Your life relies on software in vehicles, hospitals and banks.</p>

<p>With software becoming so commonplace, the burden to produce quality software is greater than ever. Software verification is a critical area of the development process that has been shit on and forgotten for over forty years. Today&#8217;s state of the art in quality assurance is a combination between exploratory testing and developer-written regression suites. In other words, if you don&#8217;t think about verification, then none happens at all.</p>

<p>These problems are both huge. We must solve them, and wetware solutions will be woefully inadequate. We need to adopt and develop new languages and tools that directly address these issues. This is the area where we have <em>regressed</em> from forty years ago. Back then programmers quickly grew impatient with wetware solutions and would write software to automate things and introduce abstractions: programming languages, parser and scanner generators, build automation tools, build configuration tools, stream editors, and the list just goes on.</p>

<p>Somewhere in the last forty years, we just gave up. As an industry, we decided that languages and tool-chains were fundamentally solved problems, and all we needed to do was evolve the syntax and libraries. We have eschewed the <a href='http://c2.com/cgi/wiki?LazinessImpatienceHubris'>virtuous</a> path of software development in favor of a naively pragmatic alternative. Rather than working smarter, we try to work faster. Rather than finding smarter people, we just find <em>more</em> people. These days, there&#8217;s an alternative to working in food service: <a href='http://steve.yegge.googlepages.com/choosing-languages'>programming</a>.</p></div>
  <p class="metadata alt">You may notice that I do not provide a space
    for comments. If you want to start a conversation, you can
    <a href="mailto:blog@alieniloquent.com">email me</a>, 
    <a href="http://twitter.com/stesla">tweet at me</a>, or post
    something on your own blog.</p>
</div>

       </div>
     </div>
     <div class="yui-b">
       <div class="yui-u sidebar">
         <h2 class="sectionheader first">Archives</h2>
         <ul>
           
           <li><a href="/2011/">2011</a></li>
           
           <li><a href="/2010/">2010</a></li>
           
           <li><a href="/2009/">2009</a></li>
           
           <li><a href="/2008/">2008</a></li>
           
           <li><a href="/2007/">2007</a></li>
           
           <li><a href="/2006/">2006</a></li>
           
           <li><a href="/2005/">2005</a></li>
           
         </ul>
       </div>
     </div>
   </div>
   <div id="ft">
     <p>Layout, design, graphics, photography and text all &copy; 2005-2010 Samuel Tesla unless otherwise noted.</p>
     <p>Portions of the site layout use Yahoo! YUI Reset, Fonts &amp; Grids.</p>
   </div>
 </div>

<!-- BEGIN GOOGLE ANALYTICS -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-12538528-2");
pageTracker._setDomainName(".alieniloquent.com");
pageTracker._trackPageview();
} catch(err) {}</script>
<!-- END GOOGLE ANALYTICS -->

</body>
</html>
